"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AppStateListener = void 0;
var _videoReactBindings = require("@stream-io/video-react-bindings");
var _react = require("react");
var _reactNative = require("react-native");
var _shouldDisableIOSLocalVideoOnBackground = require("../../utils/internal/shouldDisableIOSLocalVideoOnBackground");
var _rxSubjects = require("../../utils/internal/rxSubjects");
var _videoClient = require("@stream-io/video-client");
const PIP_CHANGE_EVENT = 'StreamVideoReactNative_PIP_CHANGE_EVENT';
const isAndroid8OrAbove = _reactNative.Platform.OS === 'android' && _reactNative.Platform.Version >= 26;

// Does 2 functionalities:
// 1. Resume/Disable video stream tracks when app goes to background/foreground - To save on CPU resources
// 2. Handle PiP mode in Android
const AppStateListener = () => {
  const call = (0, _videoReactBindings.useCall)();
  const appState = (0, _react.useRef)(_reactNative.AppState.currentState);
  const cameraDisabledByAppState = (0, _react.useRef)(false);

  // on mount: set initial PiP mode and listen to PiP events
  (0, _react.useEffect)(() => {
    if (!isAndroid8OrAbove) {
      return;
    }
    const disablePiP = _videoClient.RxUtils.getCurrentValue(_rxSubjects.disablePiPMode$);
    const logger = (0, _videoClient.getLogger)(['AppStateListener']);
    const initialPipMode = !disablePiP && _reactNative.AppState.currentState === 'background';
    _rxSubjects.isInPiPModeAndroid$.next(initialPipMode);
    logger('debug', 'Initial PiP mode on mount set to ', initialPipMode);
    _reactNative.NativeModules?.StreamVideoReactNative?.isInPiPMode().then(isInPiP => {
      _rxSubjects.isInPiPModeAndroid$.next(!!isInPiP);
      logger('debug', 'Initial PiP mode on mount (after asking native module) set to ', !!isInPiP);
    });
    const eventEmitter = new _reactNative.NativeEventEmitter(_reactNative.NativeModules.StreamVideoReactNative);
    const subscriptionPiPChange = eventEmitter.addListener(PIP_CHANGE_EVENT, isInPiPMode => {
      _rxSubjects.isInPiPModeAndroid$.next(isInPiPMode);
    });
    return () => {
      subscriptionPiPChange.remove();
    };
  }, []);
  (0, _react.useEffect)(() => {
    // due to strange behavior in iOS when app goes to "inactive" state
    // we dont check for inactive states
    // ref: https://www.reddit.com/r/reactnative/comments/15kib42/appstate_behavior_in_ios_when_swiping_down_to/
    const subscription = _reactNative.AppState.addEventListener('change', nextAppState => {
      const logger = (0, _videoClient.getLogger)(['AppStateListener']);
      if (appState.current.match(/background/) && nextAppState === 'active') {
        if (call?.camera?.state.status === 'enabled') {
          // Android: when device is locked and resumed, the status isnt made disabled but stays enabled
          // iOS PiP: when local track was replaced by remote track, the local track shown is blank
          // as a workaround we stop the track and enable again if its already in enabled state
          call?.camera?.disable(true).then(() => {
            call?.camera?.enable();
          });
          logger('debug', 'Disable and reenable camera as app came to foreground');
        } else {
          if (cameraDisabledByAppState.current) {
            call?.camera?.resume();
            cameraDisabledByAppState.current = false;
            logger('debug', 'Resume camera as app came to foreground');
          }
        }
        appState.current = nextAppState;
      } else if (appState.current === 'active' && nextAppState.match(/background/)) {
        const disableCameraIfNeeded = () => {
          if (call?.camera?.state.status === 'enabled') {
            cameraDisabledByAppState.current = true;
            call?.camera?.disable();
            logger('debug', 'Camera disabled by app going to background');
          }
        };
        if (_reactNative.Platform.OS === 'android') {
          // in Android, we need to check if we are in PiP mode
          // in PiP mode, we don't want to disable the camera
          if (isAndroid8OrAbove) {
            // set with an assumption that its enabled so that UI disabling happens faster
            const disablePiP = _videoClient.RxUtils.getCurrentValue(_rxSubjects.disablePiPMode$);
            _rxSubjects.isInPiPModeAndroid$.next(!disablePiP);
            // if PiP was not enabled anyway, then in the next code we ll set it to false and UI wont be shown anyway
            _reactNative.NativeModules?.StreamVideoReactNative?.isInPiPMode().then(isInPiP => {
              _rxSubjects.isInPiPModeAndroid$.next(!!isInPiP);
              if (!isInPiP) {
                if (_reactNative.AppState.currentState === 'active') {
                  // this is to handle the case that the app became active as soon as it went to background
                  // in this case, we dont want to disable the camera
                  // this happens on foreground push notifications
                  return;
                }
                disableCameraIfNeeded();
              }
            });
          } else {
            disableCameraIfNeeded();
          }
        } else {
          // shouldDisableIOSLocalVideoOnBackgroundRef is false, if local video is enabled on PiP
          if (_shouldDisableIOSLocalVideoOnBackground.shouldDisableIOSLocalVideoOnBackgroundRef.current) {
            disableCameraIfNeeded();
          }
        }
        appState.current = nextAppState;
      }
    });
    return () => {
      subscription.remove();
    };
  }, [call]);
  return null;
};
exports.AppStateListener = AppStateListener;
//# sourceMappingURL=AppStateListener.js.map