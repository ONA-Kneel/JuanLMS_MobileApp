"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useScreenshotIosContext = exports.ScreenshotIosContextProvider = void 0;
var _videoClient = require("@stream-io/video-client");
var _react = _interopRequireWildcard(require("react"));
var _reactNative = require("react-native");
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
const {
  StreamVideoReactNative
} = _reactNative.NativeModules;
// Create the context with a default undefined value
const ScreenshotIosContext = /*#__PURE__*/(0, _react.createContext)(undefined);
const participantVideoViewRefMap = new Map();
const ScreenshotIosContextProvider = ({
  children
}) => {
  // Register a participant's RTCView ref
  const register = (0, _react.useCallback)((participant, videoTrackType, ref) => {
    if (ref && participant.userId) {
      participantVideoViewRefMap.set(`${participant.userId}-${videoTrackType}`, ref);
    }
  }, []);
  const deregister = (0, _react.useCallback)((participant, videoTrackType) => {
    if (participant.userId) {
      participantVideoViewRefMap.delete(`${participant.userId}-${videoTrackType}`);
    }
  }, []);

  // Take a snapshot of a specific participant's view
  const take = (0, _react.useCallback)(async (participant, videoTrackType) => {
    try {
      if (_reactNative.Platform.OS !== 'ios') {
        throw new Error('ScreenshotIosContextProvider is only supported on iOS');
      }
      const ref = participantVideoViewRefMap.get(`${participant.userId}-${videoTrackType}`);
      if (!ref || !ref.current) {
        (0, _videoClient.getLogger)(['ScreenshotIosContextProvider'])('error', 'Cannot take snapshot: No registered view for this participant');
        return null;
      }

      // Get the native handle for the view
      const tag = (0, _reactNative.findNodeHandle)(ref.current);
      if (!tag) {
        (0, _videoClient.getLogger)(['ScreenshotIosContextProvider'])('error', 'Cannot take snapshot: Cannot get native handle for view');
        return null;
      }

      // Take the snapshot using our native module
      const base64Image = await StreamVideoReactNative.captureRef(tag, {});
      return base64Image;
    } catch (error) {
      (0, _videoClient.getLogger)(['ScreenshotIosContextProvider'])('error', 'Error taking participant snapshot:', error);
      return null;
    }
  }, []);
  const value = (0, _react.useMemo)(() => ({
    register,
    deregister,
    take
  }), [register, deregister, take]);
  return /*#__PURE__*/_react.default.createElement(ScreenshotIosContext.Provider, {
    value: value
  }, children);
};
exports.ScreenshotIosContextProvider = ScreenshotIosContextProvider;
const useScreenshotIosContext = () => {
  const context = (0, _react.useContext)(ScreenshotIosContext);
  if (!context) {
    throw new Error('useScreenshotIosContext must be used within a ScreenshotIosContextProvider');
  }
  return context;
};
exports.useScreenshotIosContext = useScreenshotIosContext;
//# sourceMappingURL=ScreenshotIosContext.js.map