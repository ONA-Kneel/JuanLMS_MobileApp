"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setupIosCallKeepEvents = setupIosCallKeepEvents;
var _rxSubjects = require("./internal/rxSubjects");
var _videoClient = require("@stream-io/video-client");
var _libs = require("./libs");
var _utils = require("./internal/utils");
var _reactNative = require("react-native");
var _pushLogoutCallback = require("../internal/pushLogoutCallback");
/**
 * This hook is used to listen to callkeep events and do the necessary actions
 */
function setupIosCallKeepEvents(pushConfig) {
  if (_reactNative.Platform.OS !== 'ios' || !pushConfig.ios.pushProviderName) {
    return;
  }
  if (!pushConfig.android.incomingCallChannel) {
    // TODO: remove this check and find a better way once we have telecom integration for android
    (0, _videoClient.getLogger)(['setupIosCallKeepEvents'])('debug', 'android incomingCallChannel is not defined, so skipping the setupIosCallKeepEvents');
    return;
  }
  const logger = (0, _videoClient.getLogger)(['setupIosCallKeepEvents']);
  const callkeep = (0, _libs.getCallKeepLib)();
  async function getCallCid(callUUID) {
    let call_cid = _videoClient.RxUtils.getCurrentValue(_rxSubjects.voipPushNotificationCallCId$);
    if (!call_cid) {
      // if call_cid is not available, try to get it from native module
      try {
        call_cid = await _reactNative.NativeModules?.StreamVideoReactNative?.getIncomingCallCid(callUUID);
        _rxSubjects.voipPushNotificationCallCId$.next(call_cid);
      } catch (error) {
        logger('debug', 'Error in getting call cid from native module - probably the call was already processed, so ignoring this callkeep event', error);
      }
    }
    return call_cid;
  }
  function answerCall(callUUID) {
    getCallCid(callUUID).then(call_cid => {
      logger('debug', `answerCall event with call_cid: ${call_cid}`);
      iosCallkeepAcceptCall(call_cid, callUUID);
    });
  }
  function endCall(callUUID) {
    getCallCid(callUUID).then(call_cid => {
      logger('debug', `endCall event with call_cid: ${call_cid}`);
      iosCallkeepRejectCall(call_cid, callUUID, pushConfig);
    });
  }
  function didDisplayIncomingCall(callUUID, payload) {
    const voipPushNotification = (0, _libs.getVoipPushNotificationLib)();
    // @ts-expect-error - call_cid is not part of RNCallKeepEventPayload
    const call_cid = payload?.call_cid;
    logger('debug', `didDisplayIncomingCall event with callUUID: ${callUUID} call_cid: ${call_cid}`);
    if (call_cid) {
      if (_reactNative.AppState.currentState === 'background') {
        (0, _utils.processCallFromPushInBackground)(pushConfig, call_cid, 'backgroundDelivered');
      }
      _rxSubjects.voipCallkeepCallOnForegroundMap$.next({
        uuid: callUUID,
        cid: call_cid
      });
    }
    voipPushNotification.onVoipNotificationCompleted(callUUID);
  }
  const {
    remove: removeAnswerCall
  } = callkeep.addEventListener('answerCall', ({
    callUUID
  }) => {
    answerCall(callUUID);
  });
  const {
    remove: removeEndCall
  } = callkeep.addEventListener('endCall', ({
    callUUID
  }) => {
    endCall(callUUID);
  });
  const {
    remove: removeDisplayIncomingCall
  } = callkeep.addEventListener('didDisplayIncomingCall', ({
    callUUID,
    payload
  }) => {
    didDisplayIncomingCall(callUUID, payload);
  });
  const {
    remove: removeDidLoadWithEvents
  } = callkeep.addEventListener('didLoadWithEvents', events => {
    if (!events || !Array.isArray(events) || events.length < 1) {
      return;
    }
    events.forEach(event => {
      const {
        name,
        data
      } = event;
      if (name === 'RNCallKeepDidDisplayIncomingCall') {
        didDisplayIncomingCall(data.callUUID, data.payload);
      } else if (name === 'RNCallKeepPerformAnswerCallAction') {
        answerCall(data.callUUID);
      } else if (name === 'RNCallKeepPerformEndCallAction') {
        endCall(data.callUUID);
      }
    });
  });
  (0, _pushLogoutCallback.setPushLogoutCallback)(async () => {
    removeAnswerCall();
    removeEndCall();
    removeDisplayIncomingCall();
    removeDidLoadWithEvents();
  });
}
const iosCallkeepAcceptCall = (call_cid, callUUIDFromCallkeep) => {
  if (!shouldProcessCallFromCallkeep(call_cid, callUUIDFromCallkeep)) {
    return;
  }
  (0, _utils.clearPushWSEventSubscriptions)();
  // to call end callkeep later if ended in app and not through callkeep
  _rxSubjects.voipCallkeepAcceptedCallOnNativeDialerMap$.next({
    uuid: callUUIDFromCallkeep,
    cid: call_cid
  });
  // to process the call in the app
  _rxSubjects.pushAcceptedIncomingCallCId$.next(call_cid);
  // no need to keep these references anymore
  _rxSubjects.voipCallkeepCallOnForegroundMap$.next(undefined);
};
const iosCallkeepRejectCall = async (call_cid, callUUIDFromCallkeep, pushConfig) => {
  if (!shouldProcessCallFromCallkeep(call_cid, callUUIDFromCallkeep)) {
    return;
  }
  (0, _utils.clearPushWSEventSubscriptions)();
  // no need to keep these references anymore
  _rxSubjects.voipCallkeepAcceptedCallOnNativeDialerMap$.next(undefined);
  _rxSubjects.voipCallkeepCallOnForegroundMap$.next(undefined);
  _rxSubjects.voipPushNotificationCallCId$.next(undefined);
  await (0, _utils.processCallFromPushInBackground)(pushConfig, call_cid, 'decline');
  await _reactNative.NativeModules.StreamVideoReactNative?.removeIncomingCall(call_cid);
};

/**
 * Helper function to determine if the answer/end call event from callkeep must be processed
 * Just checks if we have a valid call_cid and acts as a type guard for call_cid
 */
const shouldProcessCallFromCallkeep = (call_cid, callUUIDFromCallkeep) => {
  if (!call_cid || !callUUIDFromCallkeep) {
    return false;
  }
  return true;
};
//# sourceMappingURL=setupIosCallKeepEvents.js.map