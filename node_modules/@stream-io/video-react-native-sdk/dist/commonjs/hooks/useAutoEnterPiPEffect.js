"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useAutoEnterPiPEffect = useAutoEnterPiPEffect;
var _videoClient = require("@stream-io/video-client");
var _videoReactBindings = require("@stream-io/video-react-bindings");
var _react = require("react");
var _reactNative = require("react-native");
var _rxSubjects = require("../utils/internal/rxSubjects");
function useAutoEnterPiPEffect(disablePictureInPicture) {
  const {
    useCallCallingState
  } = (0, _videoReactBindings.useCallStateHooks)();
  const callingState = useCallCallingState();

  // if we need to enable autoEnter, only enable in joined state
  (0, _react.useEffect)(() => {
    if (_reactNative.Platform.OS !== 'android') {
      return;
    }
    if (!disablePictureInPicture && callingState === _videoClient.CallingState.JOINED) {
      _reactNative.NativeModules.StreamVideoReactNative.canAutoEnterPipMode(!disablePictureInPicture);
    }
  }, [callingState, disablePictureInPicture]);
  (0, _react.useEffect)(() => {
    _rxSubjects.disablePiPMode$.next(disablePictureInPicture === true);
    if (_reactNative.Platform.OS !== 'android') {
      return;
    }

    // on unmount always disable PiP mode auto enter
    return () => {
      _reactNative.NativeModules.StreamVideoReactNative.canAutoEnterPipMode(false);
    };
  }, [disablePictureInPicture]);

  // if disable prop was sent, immediately disable PiP mode
  (0, _react.useEffect)(() => {
    if (_reactNative.Platform.OS !== 'android') {
      return;
    }
    if (disablePictureInPicture) {
      _reactNative.NativeModules.StreamVideoReactNative.canAutoEnterPipMode(false);
    }
  }, [disablePictureInPicture]);
}
//# sourceMappingURL=useAutoEnterPiPEffect.js.map