"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CallContent = void 0;
var _react = _interopRequireWildcard(require("react"));
var _reactNative = require("react-native");
var _reactNativeIncallManager = _interopRequireDefault(require("react-native-incall-manager"));
var _CallLayout = require("../CallLayout");
var _CallControls = require("../CallControls");
var _videoReactBindings = require("@stream-io/video-react-bindings");
var _videoClient = require("@stream-io/video-client");
var _constants = require("../../../constants");
var _hooks = require("../../../utils/hooks");
var _Participant = require("../../Participant");
var _contexts = require("../../../contexts");
var _hooks2 = require("../../../hooks");
var _ScreenShareOverlay = require("../../utility/ScreenShareOverlay");
var _RTCViewPipIOS = require("./RTCViewPipIOS");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }
const CallContent = ({
  onHangupCallHandler,
  CallParticipantsList,
  CallControls = _CallControls.CallControls,
  FloatingParticipantView = _Participant.FloatingParticipantView,
  ScreenShareOverlay = _ScreenShareOverlay.ScreenShareOverlay,
  ParticipantLabel,
  ParticipantNetworkQualityIndicator,
  ParticipantReaction,
  ParticipantVideoFallback,
  ParticipantView,
  VideoRenderer,
  layout = 'grid',
  landscape = false,
  supportedReactions,
  iOSPiPIncludeLocalParticipantVideo,
  disablePictureInPicture,
  initialInCallManagerAudioMode = 'video'
}) => {
  const [showRemoteParticipantInFloatingView, setShowRemoteParticipantInFloatingView] = (0, _react.useState)(false);
  const styles = useStyles();
  const {
    theme: {
      callContent
    }
  } = (0, _contexts.useTheme)();
  const call = (0, _videoReactBindings.useCall)();
  const {
    useHasOngoingScreenShare,
    useRemoteParticipants,
    useLocalParticipant
  } = (0, _videoReactBindings.useCallStateHooks)();
  (0, _hooks2.useAutoEnterPiPEffect)(disablePictureInPicture);
  const incallManagerModeRef = (0, _react.useRef)(initialInCallManagerAudioMode);
  const _remoteParticipants = useRemoteParticipants();
  const remoteParticipants = (0, _hooks.useDebouncedValue)(_remoteParticipants, 300); // we debounce the remote participants to avoid unnecessary rerenders that happen when participant tracks are all subscribed simultaneously
  const localParticipant = useLocalParticipant();
  const isInPiPMode = (0, _hooks2.useIsInPiPMode)();
  const hasScreenShare = useHasOngoingScreenShare();
  const showSpotlightLayout = hasScreenShare || layout === 'spotlight';
  (0, _react.useEffect)(() => {
    if (isInPiPMode && _reactNative.Platform.OS === 'android') {
      const unsubFunc = call?.on('call.ended', () => {
        (0, _videoClient.getLogger)(['CallContent'])('debug', `exiting PiP mode due to call.ended`);
        _reactNative.NativeModules.StreamVideoReactNative.exitPipMode();
      });
      const subscription = call?.state.callingState$.subscribe(state => {
        if (state === _videoClient.CallingState.LEFT) {
          (0, _videoClient.getLogger)(['CallContent'])('debug', `exiting PiP mode due to callingState: LEFT`);
          _reactNative.NativeModules.StreamVideoReactNative.exitPipMode();
        }
      });
      return () => {
        unsubFunc?.();
        subscription?.unsubscribe();
      };
    }
  }, [isInPiPMode, call]);
  const showFloatingView = !showSpotlightLayout && !isInPiPMode && remoteParticipants.length > 0 && remoteParticipants.length < 3;
  const isRemoteParticipantInFloatingView = showFloatingView && showRemoteParticipantInFloatingView && remoteParticipants.length === 1;

  /**
   * This hook is used to handle IncallManager specs of the application.
   */
  (0, _react.useEffect)(() => {
    _reactNativeIncallManager.default.start({
      media: incallManagerModeRef.current
    });
    return () => _reactNativeIncallManager.default.stop();
  }, []);
  const handleFloatingViewParticipantSwitch = () => {
    if (remoteParticipants.length !== 1) {
      return;
    }
    setShowRemoteParticipantInFloatingView(prevState => !prevState);
  };
  const participantViewProps = {
    ParticipantLabel: isInPiPMode ? null : ParticipantLabel,
    ParticipantNetworkQualityIndicator: isInPiPMode ? null : ParticipantNetworkQualityIndicator,
    ParticipantReaction,
    ParticipantVideoFallback,
    VideoRenderer
  };
  const callParticipantsGridProps = {
    ...participantViewProps,
    landscape,
    showLocalParticipant: isRemoteParticipantInFloatingView,
    ParticipantView,
    CallParticipantsList,
    supportedReactions
  };
  const callParticipantsSpotlightProps = {
    ...participantViewProps,
    landscape,
    ParticipantView,
    CallParticipantsList,
    ScreenShareOverlay,
    supportedReactions
  };
  const landscapeStyles = {
    flexDirection: landscape ? 'row' : 'column'
  };
  return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, !disablePictureInPicture && /*#__PURE__*/_react.default.createElement(_RTCViewPipIOS.RTCViewPipIOS, {
    includeLocalParticipantVideo: iOSPiPIncludeLocalParticipantVideo
  }), /*#__PURE__*/_react.default.createElement(_reactNative.View, {
    style: [styles.container, landscapeStyles, callContent.container]
  }, /*#__PURE__*/_react.default.createElement(_reactNative.View, {
    style: [styles.content, callContent.callParticipantsContainer]
  }, /*#__PURE__*/_react.default.createElement(_reactNative.View, {
    style: [styles.view, callContent.topContainer]
    // "box-none" disallows the container view to be not take up touches
    // and allows only the top and floating view (its child views) to take up the touches
    ,
    pointerEvents: "box-none"
  }, showFloatingView && FloatingParticipantView && /*#__PURE__*/_react.default.createElement(FloatingParticipantView, _extends({
    participant: isRemoteParticipantInFloatingView ? remoteParticipants[0] : localParticipant,
    onPressHandler: handleFloatingViewParticipantSwitch,
    supportedReactions: supportedReactions,
    objectFit: "cover"
  }, participantViewProps))), showSpotlightLayout ? /*#__PURE__*/_react.default.createElement(_CallLayout.CallParticipantsSpotlight, callParticipantsSpotlightProps) : /*#__PURE__*/_react.default.createElement(_CallLayout.CallParticipantsGrid, callParticipantsGridProps)), !isInPiPMode && CallControls && /*#__PURE__*/_react.default.createElement(CallControls, {
    onHangupCallHandler: onHangupCallHandler,
    landscape: landscape
  })));
};
exports.CallContent = CallContent;
const useStyles = () => {
  const {
    theme
  } = (0, _contexts.useTheme)();
  return (0, _react.useMemo)(() => _reactNative.StyleSheet.create({
    container: {
      flex: 1,
      paddingBottom: theme.variants.insets.bottom,
      paddingLeft: theme.variants.insets.left,
      paddingRight: theme.variants.insets.right,
      paddingTop: theme.variants.insets.top,
      backgroundColor: theme.colors.sheetPrimary
    },
    content: {
      flex: 1
    },
    view: {
      ..._reactNative.StyleSheet.absoluteFillObject,
      zIndex: _constants.Z_INDEX.IN_FRONT
    }
  }), [theme]);
};
//# sourceMappingURL=CallContent.js.map