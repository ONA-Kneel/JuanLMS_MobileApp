"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RTCViewPipIOS = void 0;
var _videoClient = require("@stream-io/video-client");
var _videoReactBindings = require("@stream-io/video-react-bindings");
var _react = _interopRequireWildcard(require("react"));
var _reactNative = require("react-native");
var _RTCViewPipNative = require("./RTCViewPipNative");
var _hooks = require("../../../utils/hooks");
var _shouldDisableIOSLocalVideoOnBackground = require("../../../utils/internal/shouldDisableIOSLocalVideoOnBackground");
var _useTrackDimensions = require("../../../hooks/useTrackDimensions");
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
const RTCViewPipIOS = exports.RTCViewPipIOS = /*#__PURE__*/_react.default.memo(props => {
  const {
    includeLocalParticipantVideo
  } = props;
  const call = (0, _videoReactBindings.useCall)();
  const {
    useParticipants
  } = (0, _videoReactBindings.useCallStateHooks)();
  const _allParticipants = useParticipants({
    sortBy: _videoClient.speakerLayoutSortPreset
  });
  const allParticipants = (0, _hooks.useDebouncedValue)(_allParticipants, 300); // we debounce the participants to avoid unnecessary rerenders that happen when participant tracks are all subscribed simultaneously

  const [dominantSpeaker, dominantSpeaker2] = allParticipants.filter(participant => includeLocalParticipantVideo ? true : !participant.isLocalParticipant);

  // show the dominant remote speaker in PiP mode
  // local speaker is shown only if remote doesn't exist
  let participantInSpotlight = dominantSpeaker;
  if (dominantSpeaker?.isLocalParticipant && dominantSpeaker2) {
    participantInSpotlight = dominantSpeaker2;
  }
  (0, _react.useEffect)(() => {
    _shouldDisableIOSLocalVideoOnBackground.shouldDisableIOSLocalVideoOnBackgroundRef.current = !includeLocalParticipantVideo;
  }, [includeLocalParticipantVideo]);
  const nativeRef = _react.default.useRef(null);
  _react.default.useEffect(() => {
    let callClosedInvokedOnce = false;
    const onCallClosed = () => {
      if (callClosedInvokedOnce) {
        return;
      }
      callClosedInvokedOnce = true;
      const node = (0, _reactNative.findNodeHandle)(nativeRef.current);
      if (node !== null) {
        (0, _RTCViewPipNative.onNativeCallClosed)(node);
      }
      _shouldDisableIOSLocalVideoOnBackground.shouldDisableIOSLocalVideoOnBackgroundRef.current = true;
    };
    const unsubFunc = call?.on('call.ended', () => {
      (0, _videoClient.getLogger)(['RTCViewPipIOS'])('debug', `onCallClosed due to call.ended event`);
      onCallClosed();
    });
    const subscription = call?.state.callingState$.subscribe(state => {
      if (state === _videoClient.CallingState.LEFT) {
        (0, _videoClient.getLogger)(['RTCViewPipIOS'])('debug', `onCallClosed due to callingState: ${state}`);
        onCallClosed();
      }
    });
    return () => {
      onCallClosed();
      unsubFunc?.();
      subscription?.unsubscribe();
    };
  }, [call]);
  const onDimensionsUpdated = (0, _react.useCallback)((width, height) => {
    const node = (0, _reactNative.findNodeHandle)(nativeRef.current);
    if (node !== null && width > 0 && height > 0) {
      (0, _RTCViewPipNative.onNativeDimensionsUpdated)(node, width, height);
    }
  }, []);
  const {
    videoStream,
    screenShareStream
  } = participantInSpotlight || {};
  const isScreenSharing = participantInSpotlight ? (0, _videoClient.hasScreenShare)(participantInSpotlight) : false;
  const videoStreamToRender = isScreenSharing ? screenShareStream : videoStream;
  const streamURL = (0, _react.useMemo)(() => {
    if (!videoStreamToRender) {
      return undefined;
    }
    return videoStreamToRender?.toURL();
  }, [videoStreamToRender]);
  return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(_RTCViewPipNative.RTCViewPipNative, {
    streamURL: streamURL,
    ref: nativeRef
  }), participantInSpotlight && /*#__PURE__*/_react.default.createElement(DimensionsUpdatedRenderless, {
    participant: participantInSpotlight,
    trackType: isScreenSharing ? 'screenShareTrack' : 'videoTrack',
    onDimensionsUpdated: onDimensionsUpdated,
    key: streamURL
  }));
});
const DimensionsUpdatedRenderless = /*#__PURE__*/_react.default.memo(({
  participant,
  trackType,
  onDimensionsUpdated
}) => {
  const {
    width,
    height
  } = (0, _useTrackDimensions.useTrackDimensions)(participant, trackType);
  (0, _react.useEffect)(() => {
    onDimensionsUpdated(width, height);
  }, [width, height, onDimensionsUpdated]);
  return null;
});
DimensionsUpdatedRenderless.displayName = 'DimensionsUpdatedRenderless';
RTCViewPipIOS.displayName = 'RTCViewPipIOS';
//# sourceMappingURL=RTCViewPipIOS.js.map