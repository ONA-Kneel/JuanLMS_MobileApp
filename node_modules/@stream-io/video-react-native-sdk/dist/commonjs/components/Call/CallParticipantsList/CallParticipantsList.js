"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CallParticipantsList = void 0;
var _react = _interopRequireWildcard(require("react"));
var _reactNative = require("react-native");
var _videoClient = require("@stream-io/video-client");
var _useDebouncedValue = require("../../../utils/hooks/useDebouncedValue");
var _videoReactBindings = require("@stream-io/video-react-bindings");
var _TestIds = require("../../../constants/TestIds");
var _ParticipantView = require("../../Participant/ParticipantView");
var _contexts = require("../../../contexts");
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }
const VIEWABILITY_CONFIG = {
  waitForInteraction: false,
  itemVisiblePercentThreshold: 60
};

/**
 * Props of the CallParticipantsList component
 */

/**
 * This component displays a list of participants in a FlatList.
 * You can use this component to display participants either in a vertical or horizontal scrolling mode.
 * NOTE: this component depends on a flex container to calculate the width and height of the participant view,
 * hence it should be used only in a flex parent container
 */
const CallParticipantsList = ({
  numberOfColumns = 2,
  horizontal,
  participants,
  ParticipantView = _ParticipantView.ParticipantView,
  ParticipantLabel,
  ParticipantNetworkQualityIndicator,
  ParticipantReaction,
  ParticipantVideoFallback,
  VideoRenderer,
  supportedReactions,
  landscape
}) => {
  const styles = useStyles();
  const [containerLayout, setContainerLayout] = (0, _react.useState)({
    width: 0,
    height: 0
  });

  // we use a HashSet to track the currently viewable participants
  // and a separate force update state to rerender the component to inform that the HashSet has changed
  // NOTE: we use set instead of array or object for O(1) lookup, add and delete
  const viewableParticipantSessionIds = (0, _react.useRef)(new Set());
  const [_forceUpdateValue, forceUpdate] = (0, _react.useReducer)(x => x + 1, 0);
  const forceUpdateValue = (0, _useDebouncedValue.useDebouncedValue)(_forceUpdateValue, 500); // we debounce forced value to avoid multiple viewability change continuous rerenders due to callbacks that occurs simultaneously during a large list scroll or when scrolling is completed

  // we use a ref to store the active call object
  // so that it can be used in the onViewableItemsChanged callback
  const activeCall = (0, _videoReactBindings.useCall)();
  const activeCallRef = (0, _react.useRef)(activeCall);
  activeCallRef.current = activeCall;
  // This is the function that gets called when the user scrolls the list of participants.
  // It updates viewableParticipantSessionIds HashSet with the session IDs
  // of the participants that are currently visible.
  const onViewableItemsChanged = (0, _react.useRef)(({
    viewableItems
  }) => {
    const participantPatches = {};
    let mustUpdate = false;
    const newVisibleParticipantSessionIds = new Set(viewableItems.map(v => v.key));
    const oldVisibleParticipantSessionIds = viewableParticipantSessionIds.current;
    newVisibleParticipantSessionIds.forEach(key => {
      if (!oldVisibleParticipantSessionIds.has(key)) {
        mustUpdate = true;
        participantPatches[key] = {
          viewportVisibilityState: {
            videoTrack: _videoClient.VisibilityState.VISIBLE,
            screenShareTrack: _videoClient.VisibilityState.UNKNOWN
          }
        };
      }
    });
    oldVisibleParticipantSessionIds.forEach(key => {
      if (!newVisibleParticipantSessionIds.has(key)) {
        mustUpdate = true;
        participantPatches[key] = {
          viewportVisibilityState: {
            videoTrack: _videoClient.VisibilityState.VISIBLE,
            screenShareTrack: _videoClient.VisibilityState.UNKNOWN
          }
        };
      }
    });
    viewableParticipantSessionIds.current = newVisibleParticipantSessionIds;
    if (mustUpdate) {
      activeCallRef.current?.state.updateParticipants(participantPatches);
      forceUpdate();
    }
  }).current;

  // NOTE: key must be sessionId always as it is used to track viewable participants
  const keyExtractor = (0, _react.useRef)(item => item.sessionId).current;
  const onLayout = (0, _react.useRef)(event => {
    const {
      height,
      width
    } = event.nativeEvent.layout;
    setContainerLayout(prev => {
      if (prev.height === height && prev.width === width) {
        return prev;
      }
      return {
        height,
        width
      };
    });
  }).current;
  const {
    itemHeight,
    itemWidth
  } = calculateParticipantViewSize({
    containerHeight: containerLayout.height,
    containerWidth: containerLayout.width,
    participantsLength: participants.length,
    numberOfColumns,
    horizontal,
    margin: styles.participant.margin
  });
  const itemContainerStyle = (0, _react.useMemo)(() => {
    const style = {
      width: itemWidth,
      height: itemHeight,
      margin: styles.participant.margin
    };
    if (horizontal) {
      return [styles.participantWrapperHorizontal, style];
    }
    if (landscape) {
      return [styles.landScapeStyle, style];
    }
    return style;
  }, [itemWidth, itemHeight, horizontal, landscape, styles]);
  const participantProps = {
    ParticipantLabel,
    ParticipantNetworkQualityIndicator,
    ParticipantReaction,
    ParticipantVideoFallback,
    VideoRenderer
  };
  const renderItem = (0, _react.useCallback)(({
    item: participant
  }) => {
    const isVisible = viewableParticipantSessionIds.current.has(participant.sessionId);
    return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, ParticipantView && /*#__PURE__*/_react.default.createElement(ParticipantView, _extends({
      participant: participant,
      style: itemContainerStyle,
      trackType: "videoTrack",
      isVisible: isVisible,
      supportedReactions: supportedReactions
    }, participantProps)));
  },
  // eslint-disable-next-line react-hooks/exhaustive-deps
  [itemContainerStyle]);

  // in vertical mode, only when there are more than 2 participants in a call, the participants should be displayed in a grid
  // else we display them both in a stretched row on the screen
  const shouldWrapByColumns = !!horizontal || participants.length > 2;
  if (!shouldWrapByColumns) {
    return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, participants.map((participant, index) => {
      return ParticipantView && /*#__PURE__*/_react.default.createElement(ParticipantView, _extends({
        participant: participant,
        style: styles.flexed,
        trackType: "videoTrack",
        key: keyExtractor(participant, index),
        supportedReactions: supportedReactions
      }, participantProps));
    }));
  }
  return /*#__PURE__*/_react.default.createElement(_reactNative.FlatList, {
    onLayout: onLayout,
    key: !horizontal ? numberOfColumns : undefined // setting numColumns as key is a strict requirement of react-native to support changing numColumns on the fly
    ,
    data: participants,
    keyExtractor: keyExtractor,
    viewabilityConfig: VIEWABILITY_CONFIG,
    onViewableItemsChanged: onViewableItemsChanged,
    renderItem: renderItem,
    numColumns: !horizontal ? numberOfColumns : undefined,
    horizontal: horizontal,
    showsHorizontalScrollIndicator: false,
    extraData: `${forceUpdateValue}` // this is important to force re-render when visibility changes
    ,
    testID: _TestIds.ComponentTestIds.CALL_PARTICIPANTS_LIST
  });
};
exports.CallParticipantsList = CallParticipantsList;
const useStyles = () => {
  const {
    theme
  } = (0, _contexts.useTheme)();
  return (0, _react.useMemo)(() => _reactNative.StyleSheet.create({
    flexed: {
      flex: 1
    },
    participantWrapperHorizontal: {
      // note: if marginHorizontal is changed, be sure to change the width calculation in calculateParticipantViewSize function
      marginHorizontal: theme.variants.spacingSizes.sm,
      borderRadius: theme.variants.borderRadiusSizes.sm
    },
    landScapeStyle: {
      borderRadius: theme.variants.borderRadiusSizes.sm
    },
    participant: {
      margin: theme.variants.spacingSizes.xs
    }
  }), [theme]);
};

/**
 * This function calculates the size of the participant view based on the size of the container (the phone's screen size) and the number of participants.
 * @param {number} containerHeight - height of the container (the phone's screen height) in pixels
 * @param {number} containerWidth - width of the container (the phone's screen width) in pixels
 * @param {number} participantsLength - number of participants
 * @param {number} numColumns - number of columns
 * @param {boolean} horizontal - whether the participant view is in horizontal mode
 * @returns {object} - an object containing the height and width of the participant view
 */
function calculateParticipantViewSize({
  containerHeight,
  containerWidth,
  participantsLength,
  numberOfColumns,
  horizontal,
  margin
}) {
  let itemHeight = containerHeight;
  // in vertical mode, we calculate the height of the participant view based on the containerHeight (aka the phone's screen height)
  if (!horizontal) {
    if (participantsLength <= 4) {
      // special case: if there are 4 or less participants, we display them in 2 rows
      itemHeight = containerHeight / 2;
    } else {
      // generally, we display the participants in 3 rows
      itemHeight = containerHeight / 3;
    }
  }
  let itemWidth = containerWidth / numberOfColumns;
  if (horizontal) {
    // in horizontal mode we apply margin of 8 to the participant view and that should be subtracted from the width
    itemWidth = itemWidth - 8 * 2;
  }
  itemHeight = itemHeight - margin;
  itemWidth = itemWidth - margin;
  return {
    itemHeight,
    itemWidth
  };
}
//# sourceMappingURL=CallParticipantsList.js.map