"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VideoRenderer = void 0;
var _react = _interopRequireWildcard(require("react"));
var _reactNative = require("react-native");
var _reactNativeWebrtc = require("@stream-io/react-native-webrtc");
var _videoClient = require("@stream-io/video-client");
var _videoReactBindings = require("@stream-io/video-react-bindings");
var _ParticipantVideoFallback = require("./ParticipantVideoFallback");
var _ThemeContext = require("../../../contexts/ThemeContext");
var _useTrackDimensions = require("../../../hooks/useTrackDimensions");
var _ScreenshotIosContext = require("../../../contexts/internal/ScreenshotIosContext");
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
const DEFAULT_VIEWPORT_VISIBILITY_STATE = {
  videoTrack: _videoClient.VisibilityState.UNKNOWN,
  screenShareTrack: _videoClient.VisibilityState.UNKNOWN
};

/**
 * Props for the VideoRenderer component.
 */

/**
 * This component is used to display the video of the participant and fallback when the video is muted.
 *
 * It internally used `RTCView` to render video stream.
 */
const VideoRenderer = ({
  trackType = 'videoTrack',
  participant,
  isVisible = true,
  ParticipantVideoFallback = _ParticipantVideoFallback.ParticipantVideoFallback,
  objectFit,
  videoZOrder = 0
}) => {
  const {
    theme: {
      videoRenderer
    }
  } = (0, _ThemeContext.useTheme)();
  const call = (0, _videoReactBindings.useCall)();
  const {
    useCallCallingState,
    useCameraState,
    useIncomingVideoSettings
  } = (0, _videoReactBindings.useCallStateHooks)();
  const {
    isParticipantVideoEnabled
  } = useIncomingVideoSettings();
  const callingState = useCallCallingState();
  const pendingVideoLayoutRef = (0, _react.useRef)(undefined);
  const subscribedVideoLayoutRef = (0, _react.useRef)(undefined);
  const {
    direction
  } = useCameraState();
  const viewRef = (0, _react.useRef)(null);
  const {
    register: registerIosScreenshot,
    deregister: deregisterIosScreenshot
  } = (0, _ScreenshotIosContext.useScreenshotIosContext)();
  const videoDimensions = (0, _useTrackDimensions.useTrackDimensions)(participant, trackType);
  const isVideoDimensionsValid = videoDimensions.width > 0 && videoDimensions.height > 0;
  const {
    isLocalParticipant,
    sessionId,
    viewportVisibilityState,
    videoStream,
    screenShareStream
  } = participant;
  const isScreenSharing = trackType === 'screenShareTrack';
  const isPublishingVideoTrack = isScreenSharing ? (0, _videoClient.hasScreenShare)(participant) : (0, _videoClient.hasVideo)(participant);
  const hasJoinedCall = callingState === _videoClient.CallingState.JOINED;
  const videoStreamToRender = isScreenSharing ? screenShareStream : videoStream;
  const canShowVideo = !!videoStreamToRender && isVisible && isPublishingVideoTrack && !(0, _videoClient.hasPausedTrack)(participant, trackType) && isParticipantVideoEnabled(participant.sessionId);
  (0, _react.useEffect)(() => {
    if (_reactNative.Platform.OS === 'ios' && registerIosScreenshot && viewRef.current && canShowVideo) {
      registerIosScreenshot(participant, trackType, viewRef);
      return () => {
        deregisterIosScreenshot(participant, trackType);
      };
    }
  }, [participant, trackType, registerIosScreenshot, canShowVideo, deregisterIosScreenshot]);
  const mirror = isLocalParticipant && !isScreenSharing && direction === 'front';

  /**
   * This effect updates the participant's viewportVisibilityState
   * Additionally makes sure that when this view becomes visible again, the layout to subscribe is known
   */
  (0, _react.useEffect)(() => {
    if (!call || isLocalParticipant) {
      return;
    }
    if (isVisible) {
      if (trackType === 'videoTrack' && viewportVisibilityState?.videoTrack !== _videoClient.VisibilityState.VISIBLE) {
        call.state.updateParticipant(sessionId, p => ({
          ...p,
          viewportVisibilityState: {
            ...(p.viewportVisibilityState ?? DEFAULT_VIEWPORT_VISIBILITY_STATE),
            videoTrack: _videoClient.VisibilityState.VISIBLE
          }
        }));
      }
      if (trackType === 'screenShareTrack' && viewportVisibilityState?.screenShareTrack !== _videoClient.VisibilityState.VISIBLE) {
        call.state.updateParticipant(sessionId, p => ({
          ...p,
          viewportVisibilityState: {
            ...(p.viewportVisibilityState ?? DEFAULT_VIEWPORT_VISIBILITY_STATE),
            screenShareTrack: _videoClient.VisibilityState.VISIBLE
          }
        }));
      }
    } else {
      if (trackType === 'videoTrack' && viewportVisibilityState?.videoTrack !== _videoClient.VisibilityState.INVISIBLE) {
        call.state.updateParticipant(sessionId, p => ({
          ...p,
          viewportVisibilityState: {
            ...(p.viewportVisibilityState ?? DEFAULT_VIEWPORT_VISIBILITY_STATE),
            videoTrack: _videoClient.VisibilityState.INVISIBLE
          }
        }));
      }
      if (trackType === 'screenShareTrack' && viewportVisibilityState?.screenShareTrack !== _videoClient.VisibilityState.INVISIBLE) {
        call.state.updateParticipant(sessionId, p => ({
          ...p,
          viewportVisibilityState: {
            ...(p.viewportVisibilityState ?? DEFAULT_VIEWPORT_VISIBILITY_STATE),
            screenShareTrack: _videoClient.VisibilityState.INVISIBLE
          }
        }));
      }
      if (subscribedVideoLayoutRef.current) {
        // when video is enabled again, we want to use the last subscribed dimension to resubscribe
        pendingVideoLayoutRef.current = subscribedVideoLayoutRef.current;
        subscribedVideoLayoutRef.current = undefined;
      }
    }
  }, [sessionId, viewportVisibilityState, isVisible, call, trackType, isLocalParticipant]);
  (0, _react.useEffect)(() => {
    if (!hasJoinedCall && subscribedVideoLayoutRef.current) {
      // when call is joined again, we want to use the last subscribed dimension to resubscribe
      pendingVideoLayoutRef.current = subscribedVideoLayoutRef.current;
      subscribedVideoLayoutRef.current = undefined;
    }
  }, [hasJoinedCall]);

  /**
   * This effect updates the subscription either
   * 1. when video tracks are published and was unpublished before
   * 2. when the view's visibility changes
   * 3. when call was rejoined
   */
  (0, _react.useEffect)(() => {
    if (!call || isLocalParticipant) {
      return;
    }
    // NOTE: We only want to update the subscription if the pendingVideoLayoutRef is set
    const updateIsNeeded = pendingVideoLayoutRef.current;
    if (!updateIsNeeded || !isPublishingVideoTrack || !hasJoinedCall) {
      return;
    }

    // NOTE: When the view is not visible, we want to subscribe to audio only.
    // We unsubscribe their video by setting the dimension to undefined
    const dimension = isVisible ? pendingVideoLayoutRef.current : undefined;
    call.state.updateParticipantTracks(trackType, {
      [sessionId]: {
        dimension
      }
    });
    call.dynascaleManager.applyTrackSubscriptions();
    if (dimension) {
      subscribedVideoLayoutRef.current = pendingVideoLayoutRef.current;
      pendingVideoLayoutRef.current = undefined;
    }
  }, [call, isPublishingVideoTrack, trackType, isVisible, sessionId, hasJoinedCall, isLocalParticipant]);
  (0, _react.useEffect)(() => {
    return () => {
      subscribedVideoLayoutRef.current = undefined;
      pendingVideoLayoutRef.current = undefined;
    };
  }, [trackType, sessionId]);
  const onLayout = event => {
    if (!call || isLocalParticipant) {
      return;
    }
    const dimension = {
      width: Math.trunc(event.nativeEvent.layout.width),
      height: Math.trunc(event.nativeEvent.layout.height)
    };

    // NOTE: If the participant hasn't published a video track yet,
    // or the view is not viewable, we store the dimensions and handle it
    // when the track is published or the video is enabled.
    if (!isPublishingVideoTrack || !isVisible || !hasJoinedCall) {
      pendingVideoLayoutRef.current = dimension;
      return;
    }

    // NOTE: We don't want to update the subscription if the dimension hasn't changed
    if (subscribedVideoLayoutRef.current?.width === dimension.width && subscribedVideoLayoutRef.current?.height === dimension.height) {
      return;
    }
    call.state.updateParticipantTracks(trackType, {
      [sessionId]: {
        dimension
      }
    });
    call.dynascaleManager.applyTrackSubscriptions();
    subscribedVideoLayoutRef.current = dimension;
    pendingVideoLayoutRef.current = undefined;
  };
  return /*#__PURE__*/_react.default.createElement(_reactNative.View, {
    onLayout: onLayout,
    style: [styles.container, videoRenderer.container]
  }, canShowVideo && videoStreamToRender && (objectFit || isVideoDimensionsValid) ? /*#__PURE__*/_react.default.createElement(_reactNativeWebrtc.RTCView, {
    style: [styles.videoStream, videoRenderer.videoStream],
    streamURL: videoStreamToRender.toURL(),
    mirror: mirror,
    ref: viewRef,
    objectFit: objectFit ?? (videoDimensions.width > videoDimensions.height ? 'contain' : 'cover'),
    zOrder: videoZOrder
  }) : ParticipantVideoFallback && /*#__PURE__*/_react.default.createElement(ParticipantVideoFallback, {
    participant: participant
  }));
};
exports.VideoRenderer = VideoRenderer;
const styles = _reactNative.StyleSheet.create({
  container: {
    ..._reactNative.StyleSheet.absoluteFillObject
  },
  videoStream: {
    ..._reactNative.StyleSheet.absoluteFillObject
  }
});
//# sourceMappingURL=VideoRenderer.js.map