"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _react = _interopRequireWildcard(require("react"));
var _reactNative = require("react-native");
var _common = require("./common");
var _videoClient = require("@stream-io/video-client");
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }
const AnimatedFloatingView = ({
  initialAlignment,
  containerWidth,
  containerHeight,
  children
}) => {
  // the translate is calculated using distance of dragging (dx, dy)
  // computed value = value + offset
  // Start of a DRAG state: value is (0,0) and offset is the last (translateX, translateY)
  // DRAGGING state: value is always current (dx, dy) and offset is last (translateX, translateY)
  const translateRef = (0, _react.useRef)(new _reactNative.Animated.ValueXY());
  const opacity = (0, _react.useRef)(new _reactNative.Animated.Value(0));
  const [rectangle, setRectangle] = _react.default.useState();

  // we need to force update the component when the rectangle is available
  // we cannot just rely on the rectangle because it is not available on the first render
  // and we need snapAlignments to be in a Ref so that it can be used in the panResponder's creation Ref
  const [, forceUpdate] = (0, _react.useReducer)(x => x + 1, 0);

  // the offsets for the translate bounds of the floating view
  // stored in ref, because it is used in the panResponder (which has to be a ref)
  const snapAlignmentsRef = (0, _react.useRef)({
    [_common.FloatingViewAlignment.topLeft]: {
      x: 0,
      y: 0
    },
    [_common.FloatingViewAlignment.topRight]: {
      x: 0,
      y: 0
    },
    [_common.FloatingViewAlignment.bottomLeft]: {
      x: 0,
      y: 0
    },
    [_common.FloatingViewAlignment.bottomRight]: {
      x: 0,
      y: 0
    }
  });
  (0, _react.useEffect)(() => {
    if (!rectangle) {
      return;
    }
    const snapAlignments = (0, _common.getSnapAlignments)({
      rootContainerDimensions: {
        width: containerWidth,
        height: containerHeight
      },
      floatingViewDimensions: {
        width: rectangle.width,
        height: rectangle.height
      }
    });
    const {
      x,
      y
    } = snapAlignments[initialAlignment];
    snapAlignmentsRef.current = snapAlignments;
    translateRef.current.setOffset({
      x,
      y
    });
    translateRef.current.setValue({
      x: 0,
      y: 0
    });
    opacity.current.setValue(1);
    forceUpdate();
    // any time the dependency changes, we need to snap to the new alignment
  }, [initialAlignment, rectangle, containerWidth, containerHeight]);
  const panResponder = (0, _react.useRef)(_reactNative.PanResponder.create({
    onStartShouldSetPanResponder: () => true,
    onMoveShouldSetPanResponder: () => true,
    // while doing move, the value will be set to distance and offset is the current position
    // example if we 100 to the left
    // value is x:-100 y:0, offset is the previous position
    onPanResponderMove: _reactNative.Animated.event([null,
    // raw native event arg ignored
    {
      // dx, dy are the accumulated distance of the gesture since the touch started
      dx: translateRef.current.x,
      dy: translateRef.current.y
    }], {
      useNativeDriver: false // pan responder move event doesn't support nativeDriver
    }),
    onPanResponderGrant: () => {
      // start of a drag value is always (0,0) and offset is the last (translateX, translateY)
      translateRef.current.extractOffset();
    },
    onPanResponderRelease: () => {
      // make offset to 0 and value is set to the current position (so that we can do the timing animation later)
      translateRef.current.flattenOffset();
      // @ts-expect-error panResponder doesn't support nativeDriver so we can use __getValue() safely
      const currentPosition = translateRef.current.__getValue();
      const closestAlignment = (0, _common.getClosestSnapAlignment)({
        position: currentPosition,
        snapAlignments: snapAlignmentsRef.current
      });
      _reactNative.Animated.timing(translateRef.current, {
        toValue: closestAlignment,
        duration: 300,
        useNativeDriver: true,
        // can pass true since we only use transform animation
        easing: _reactNative.Easing.inOut(_reactNative.Easing.quad)
      }).start();
    }
  })).current;
  (0, _react.useEffect)(() => {
    const logger = (0, _videoClient.getLogger)(['AnimatedFloatingView']);
    logger('info', 'react-native-reanimated and/or react-native-gesture-handler libraries are not installed. Please install them to get a more performant draggable local video component');
  }, []);
  const containerStyle = {
    ...styles.animContainer,
    height: rectangle?.height,
    width: rectangle?.width,
    // do not show anything in the UI until we have the rectangle (onLayout)
    opacity: opacity.current,
    // we use interpolation to keep the value in the bounds of the necessary FloatingViewAlignment
    transform: [{
      translateX: translateRef.current.x.interpolate({
        inputRange: [0, snapAlignmentsRef.current[_common.FloatingViewAlignment.topRight].x],
        outputRange: [0, snapAlignmentsRef.current[_common.FloatingViewAlignment.topRight].x],
        extrapolate: 'clamp'
      })
    }, {
      translateY: translateRef.current.y.interpolate({
        inputRange: [0, snapAlignmentsRef.current[_common.FloatingViewAlignment.bottomRight].y],
        outputRange: [0, snapAlignmentsRef.current[_common.FloatingViewAlignment.bottomRight].y],
        extrapolate: 'clamp'
      })
    }]
  };
  return /*#__PURE__*/_react.default.createElement(_reactNative.Animated.View, _extends({
    style: containerStyle
  }, panResponder.panHandlers), /*#__PURE__*/_react.default.createElement(_reactNative.View, {
    onLayout: event => {
      const layout = event.nativeEvent.layout;
      setRectangle(prev => {
        if (prev && prev.width === layout.width && prev.height === layout.height && prev.x === layout.x && prev.y === layout.y) {
          return prev;
        }
        return layout;
      });
    },
    style: _common.floatingChildViewContainerStyle
  }, children));
};
const styles = _reactNative.StyleSheet.create({
  animContainer: {
    position: 'absolute',
    top: 0,
    left: 0
  }
});
var _default = exports.default = AnimatedFloatingView;
//# sourceMappingURL=AnimatedFloatingView.js.map