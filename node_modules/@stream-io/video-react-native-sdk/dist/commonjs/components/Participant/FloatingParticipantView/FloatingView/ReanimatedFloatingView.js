"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _react = _interopRequireWildcard(require("react"));
var _reactNative = require("react-native");
var _common = require("./common");
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
let ReanimatedFloatingView = () => {
  throw new Error('ReanimatedFloatingView component must not be used without the react-native-reanimated library and react-native-gesture-handler library installed');
};
try {
  const {
    Gesture,
    GestureDetector
  } = require('react-native-gesture-handler');
  const Reanimated = require('react-native-reanimated').default;
  const {
    useSharedValue,
    withTiming,
    useAnimatedStyle,
    withDelay
  } = require('react-native-reanimated');

  // eslint-disable-next-line react/display-name
  ReanimatedFloatingView = ({
    initialAlignment,
    containerHeight,
    containerWidth,
    children
  }) => {
    // to store the starting position of the gesture
    // NOTE: note be used for deriving styling
    const start = useSharedValue({
      x: 0,
      y: 0
    });
    // to store the necessary translate x, y position
    const translationX = useSharedValue(0);
    const translationY = useSharedValue(0);
    // we don't want to show the floating view until we have the layout rectangle
    const opacity = useSharedValue(0);
    const [rectangle, setRectangle] = _react.default.useState();
    const snapAlignments = (0, _react.useMemo)(() => {
      if (!rectangle) {
        return {
          [_common.FloatingViewAlignment.topLeft]: {
            x: 0,
            y: 0
          },
          [_common.FloatingViewAlignment.topRight]: {
            x: 0,
            y: 0
          },
          [_common.FloatingViewAlignment.bottomLeft]: {
            x: 0,
            y: 0
          },
          [_common.FloatingViewAlignment.bottomRight]: {
            x: 0,
            y: 0
          }
        };
      }
      return (0, _common.getSnapAlignments)({
        rootContainerDimensions: {
          width: containerWidth,
          height: containerHeight
        },
        floatingViewDimensions: {
          width: rectangle.width,
          height: rectangle.height
        }
      });
    }, [rectangle, containerWidth, containerHeight]);
    const dragGesture = Gesture.Pan().onStart(() => {
      start.value = {
        x: translationX.value,
        y: translationY.value
      };
    }).onUpdate(e => {
      // update the translation with the distance of the gesture + starting position
      translationX.value = Math.max(0, Math.min(e.translationX + (start.value.x ?? 0), snapAlignments[_common.FloatingViewAlignment.bottomRight].x));
      translationY.value = Math.max(0, Math.min(e.translationY + (start.value.y ?? 0), snapAlignments[_common.FloatingViewAlignment.bottomRight].y));
    }).onEnd(() => {
      // snap to the closest alignment with a spring animation
      const position = {
        x: translationX.value,
        y: translationY.value
      };
      const closestAlignment = (0, _common.getClosestSnapAlignment)({
        position,
        snapAlignments
      });
      translationX.value = withTiming(closestAlignment.x);
      translationY.value = withTiming(closestAlignment.y);
    });

    /* Move to the initial position */
    (0, _react.useEffect)(() => {
      if (!rectangle) {
        return;
      }
      const alignment = snapAlignments[initialAlignment];
      start.value = alignment;
      translationX.value = alignment.x;
      translationY.value = alignment.y;

      // add a small delay to the opacity animation to avoid
      // the floating view to be visible when it is being moved
      opacity.value = withDelay(500, withTiming(1, {
        duration: 50
      }));
    }, [rectangle, snapAlignments, initialAlignment, opacity, translationX, translationY, start]);
    const animatedStyle = useAnimatedStyle(() => {
      return {
        height: rectangle?.height,
        width: rectangle?.width,
        opacity: opacity.value,
        // to keep the value in the bounds we use min and max
        transform: [{
          translateX: translationX.value
        }, {
          translateY: translationY.value
        }]
      };
    });
    return (
      /*#__PURE__*/
      // gesture handler root view must absolutely fill the bounds
      // to intercept gestures within those bounds
      _react.default.createElement(GestureDetector, {
        gesture: dragGesture
      }, /*#__PURE__*/_react.default.createElement(Reanimated.View, {
        style: animatedStyle
      }, /*#__PURE__*/_react.default.createElement(_reactNative.View, {
        onLayout: event => {
          const layout = event.nativeEvent.layout;
          setRectangle(prev => {
            if (prev && prev.width === layout.width && prev.height === layout.height && prev.x === layout.x && prev.y === layout.y) {
              return prev;
            }
            return layout;
          });
        },
        style: _common.floatingChildViewContainerStyle
      }, children)))
    );
  };
} catch {}
var _default = exports.default = ReanimatedFloatingView;
//# sourceMappingURL=ReanimatedFloatingView.js.map