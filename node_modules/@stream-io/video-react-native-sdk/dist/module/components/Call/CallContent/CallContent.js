function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }
import React, { useEffect, useMemo, useRef, useState } from 'react';
import { StyleSheet, View, NativeModules, Platform } from 'react-native';
import InCallManager from 'react-native-incall-manager';
import { CallParticipantsGrid, CallParticipantsSpotlight } from '../CallLayout';
import { CallControls as DefaultCallControls } from '../CallControls';
import { useCall, useCallStateHooks } from '@stream-io/video-react-bindings';
import { CallingState, getLogger } from '@stream-io/video-client';
import { Z_INDEX } from '../../../constants';
import { useDebouncedValue } from '../../../utils/hooks';
import { FloatingParticipantView as DefaultFloatingParticipantView } from '../../Participant';
import { useTheme } from '../../../contexts';
import { useAutoEnterPiPEffect, useIsInPiPMode } from '../../../hooks';
import { ScreenShareOverlay as DefaultScreenShareOverlay } from '../../utility/ScreenShareOverlay';
import { RTCViewPipIOS } from './RTCViewPipIOS';
export const CallContent = ({
  onHangupCallHandler,
  CallParticipantsList,
  CallControls = DefaultCallControls,
  FloatingParticipantView = DefaultFloatingParticipantView,
  ScreenShareOverlay = DefaultScreenShareOverlay,
  ParticipantLabel,
  ParticipantNetworkQualityIndicator,
  ParticipantReaction,
  ParticipantVideoFallback,
  ParticipantView,
  VideoRenderer,
  layout = 'grid',
  landscape = false,
  supportedReactions,
  iOSPiPIncludeLocalParticipantVideo,
  disablePictureInPicture,
  initialInCallManagerAudioMode = 'video'
}) => {
  const [showRemoteParticipantInFloatingView, setShowRemoteParticipantInFloatingView] = useState(false);
  const styles = useStyles();
  const {
    theme: {
      callContent
    }
  } = useTheme();
  const call = useCall();
  const {
    useHasOngoingScreenShare,
    useRemoteParticipants,
    useLocalParticipant
  } = useCallStateHooks();
  useAutoEnterPiPEffect(disablePictureInPicture);
  const incallManagerModeRef = useRef(initialInCallManagerAudioMode);
  const _remoteParticipants = useRemoteParticipants();
  const remoteParticipants = useDebouncedValue(_remoteParticipants, 300); // we debounce the remote participants to avoid unnecessary rerenders that happen when participant tracks are all subscribed simultaneously
  const localParticipant = useLocalParticipant();
  const isInPiPMode = useIsInPiPMode();
  const hasScreenShare = useHasOngoingScreenShare();
  const showSpotlightLayout = hasScreenShare || layout === 'spotlight';
  useEffect(() => {
    if (isInPiPMode && Platform.OS === 'android') {
      const unsubFunc = call?.on('call.ended', () => {
        getLogger(['CallContent'])('debug', `exiting PiP mode due to call.ended`);
        NativeModules.StreamVideoReactNative.exitPipMode();
      });
      const subscription = call?.state.callingState$.subscribe(state => {
        if (state === CallingState.LEFT) {
          getLogger(['CallContent'])('debug', `exiting PiP mode due to callingState: LEFT`);
          NativeModules.StreamVideoReactNative.exitPipMode();
        }
      });
      return () => {
        unsubFunc?.();
        subscription?.unsubscribe();
      };
    }
  }, [isInPiPMode, call]);
  const showFloatingView = !showSpotlightLayout && !isInPiPMode && remoteParticipants.length > 0 && remoteParticipants.length < 3;
  const isRemoteParticipantInFloatingView = showFloatingView && showRemoteParticipantInFloatingView && remoteParticipants.length === 1;

  /**
   * This hook is used to handle IncallManager specs of the application.
   */
  useEffect(() => {
    InCallManager.start({
      media: incallManagerModeRef.current
    });
    return () => InCallManager.stop();
  }, []);
  const handleFloatingViewParticipantSwitch = () => {
    if (remoteParticipants.length !== 1) {
      return;
    }
    setShowRemoteParticipantInFloatingView(prevState => !prevState);
  };
  const participantViewProps = {
    ParticipantLabel: isInPiPMode ? null : ParticipantLabel,
    ParticipantNetworkQualityIndicator: isInPiPMode ? null : ParticipantNetworkQualityIndicator,
    ParticipantReaction,
    ParticipantVideoFallback,
    VideoRenderer
  };
  const callParticipantsGridProps = {
    ...participantViewProps,
    landscape,
    showLocalParticipant: isRemoteParticipantInFloatingView,
    ParticipantView,
    CallParticipantsList,
    supportedReactions
  };
  const callParticipantsSpotlightProps = {
    ...participantViewProps,
    landscape,
    ParticipantView,
    CallParticipantsList,
    ScreenShareOverlay,
    supportedReactions
  };
  const landscapeStyles = {
    flexDirection: landscape ? 'row' : 'column'
  };
  return /*#__PURE__*/React.createElement(React.Fragment, null, !disablePictureInPicture && /*#__PURE__*/React.createElement(RTCViewPipIOS, {
    includeLocalParticipantVideo: iOSPiPIncludeLocalParticipantVideo
  }), /*#__PURE__*/React.createElement(View, {
    style: [styles.container, landscapeStyles, callContent.container]
  }, /*#__PURE__*/React.createElement(View, {
    style: [styles.content, callContent.callParticipantsContainer]
  }, /*#__PURE__*/React.createElement(View, {
    style: [styles.view, callContent.topContainer]
    // "box-none" disallows the container view to be not take up touches
    // and allows only the top and floating view (its child views) to take up the touches
    ,
    pointerEvents: "box-none"
  }, showFloatingView && FloatingParticipantView && /*#__PURE__*/React.createElement(FloatingParticipantView, _extends({
    participant: isRemoteParticipantInFloatingView ? remoteParticipants[0] : localParticipant,
    onPressHandler: handleFloatingViewParticipantSwitch,
    supportedReactions: supportedReactions,
    objectFit: "cover"
  }, participantViewProps))), showSpotlightLayout ? /*#__PURE__*/React.createElement(CallParticipantsSpotlight, callParticipantsSpotlightProps) : /*#__PURE__*/React.createElement(CallParticipantsGrid, callParticipantsGridProps)), !isInPiPMode && CallControls && /*#__PURE__*/React.createElement(CallControls, {
    onHangupCallHandler: onHangupCallHandler,
    landscape: landscape
  })));
};
const useStyles = () => {
  const {
    theme
  } = useTheme();
  return useMemo(() => StyleSheet.create({
    container: {
      flex: 1,
      paddingBottom: theme.variants.insets.bottom,
      paddingLeft: theme.variants.insets.left,
      paddingRight: theme.variants.insets.right,
      paddingTop: theme.variants.insets.top,
      backgroundColor: theme.colors.sheetPrimary
    },
    content: {
      flex: 1
    },
    view: {
      ...StyleSheet.absoluteFillObject,
      zIndex: Z_INDEX.IN_FRONT
    }
  }), [theme]);
};
//# sourceMappingURL=CallContent.js.map