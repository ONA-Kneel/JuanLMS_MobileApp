import React, { useEffect, useMemo, useState } from 'react';
import { StyleSheet, View } from 'react-native';
import InCallManager from 'react-native-incall-manager';
import { useTheme } from '../../../contexts';
import { ViewerLivestreamControls as DefaultViewerLivestreamControls } from '../LivestreamControls/ViewerLivestreamControls';
import { LivestreamLayout as DefaultLivestreamLayout } from '../LivestreamLayout';
import { useCall, useCallStateHooks } from '@stream-io/video-react-bindings';
import { FloatingParticipantView as DefaultFloatingParticipantView } from '../../Participant';
import { CallingState, hasVideo } from '@stream-io/video-client';
import { CallEndedView } from '../LivestreamPlayer/LivestreamEnded';
import { ViewerLobby } from './ViewerLobby';

/**
 * Props for the ViewerLivestream component.
 */

/**
 * The ViewerLivestream component renders the UI for the Viewer's live stream.
 */
export const ViewerLivestream = ({
  ViewerLivestreamTopView,
  ViewerLivestreamControls = DefaultViewerLivestreamControls,
  LivestreamLayout = DefaultLivestreamLayout,
  FloatingParticipantView = DefaultFloatingParticipantView,
  LiveIndicator,
  FollowerCount,
  DurationBadge,
  ViewerLeaveStreamButton,
  onLeaveStreamHandler,
  joinBehavior
}) => {
  const styles = useStyles();
  const call = useCall();
  const {
    theme: {
      viewerLivestream
    }
  } = useTheme();
  const {
    useHasOngoingScreenShare,
    useParticipants,
    useCallCallingState,
    useCallEndedAt,
    useIsCallLive,
    useOwnCapabilities
  } = useCallStateHooks();
  const canJoinLive = useIsCallLive();
  const callingState = useCallCallingState();
  const endedAt = useCallEndedAt();
  const hasOngoingScreenShare = useHasOngoingScreenShare();
  const [currentSpeaker] = useParticipants();
  const floatingParticipant = hasOngoingScreenShare && currentSpeaker && hasVideo(currentSpeaker) && currentSpeaker;
  const [hasLeft, setHasLeft] = useState(false);
  const canJoinEarly = useCanJoinEarly();
  const canJoinBackstage = useOwnCapabilities()?.includes('join-backstage') ?? false;
  const [topViewHeight, setTopViewHeight] = React.useState();
  const [controlsHeight, setControlsHeight] = React.useState();

  // Automatically route audio to speaker devices as relevant for watching videos.
  useEffect(() => {
    InCallManager.start({
      media: 'video'
    });
    return () => InCallManager.stop();
  }, []);
  useEffect(() => {
    if (callingState === CallingState.LEFT) {
      setHasLeft(true);
    }
  }, [callingState]);
  const topViewProps = {
    LiveIndicator,
    FollowerCount,
    DurationBadge,
    onLayout: event => {
      setTopViewHeight(event.nativeEvent.layout.height);
    }
  };
  useEffect(() => {
    const handleJoinCall = async () => {
      try {
        await call?.join();
      } catch (error) {
        console.error('Failed to join call', error);
      }
    };
    const canJoinAsap = canJoinLive || canJoinEarly || canJoinBackstage;
    const join = joinBehavior ?? 'asap';
    const canJoin = join === 'asap' && canJoinAsap || join === 'live' && canJoinLive;
    if (call && callingState === CallingState.IDLE && canJoin && !hasLeft) {
      handleJoinCall();
    }
  }, [canJoinLive, call, canJoinBackstage, canJoinEarly, joinBehavior, callingState, hasLeft]);
  if (endedAt != null) {
    return /*#__PURE__*/React.createElement(CallEndedView, null);
  }
  if (!canJoinLive || callingState !== CallingState.JOINED) {
    return /*#__PURE__*/React.createElement(ViewerLobby, {
      isLive: canJoinLive
    });
  }
  return /*#__PURE__*/React.createElement(View, {
    style: [styles.container, viewerLivestream.container]
  }, ViewerLivestreamTopView && /*#__PURE__*/React.createElement(ViewerLivestreamTopView, topViewProps), FloatingParticipantView && floatingParticipant && topViewHeight && controlsHeight && /*#__PURE__*/React.createElement(FloatingParticipantView, {
    participant: floatingParticipant,
    draggableContainerStyle: [StyleSheet.absoluteFill, {
      top: topViewHeight,
      bottom: controlsHeight
    }]
  }), LivestreamLayout && /*#__PURE__*/React.createElement(LivestreamLayout, null), ViewerLivestreamControls && /*#__PURE__*/React.createElement(ViewerLivestreamControls, {
    ViewerLeaveStreamButton: ViewerLeaveStreamButton,
    onLeaveStreamHandler: onLeaveStreamHandler,
    onLayout: event => {
      setControlsHeight(event.nativeEvent.layout.height);
    }
  }));
};
const useCanJoinEarly = () => {
  const {
    useCallStartsAt,
    useCallSettings
  } = useCallStateHooks();
  const startsAt = useCallStartsAt();
  const settings = useCallSettings();
  const joinAheadTimeSeconds = settings?.backstage.join_ahead_time_seconds;
  const [canJoinEarly, setCanJoinEarly] = useState(() => checkCanJoinEarly(startsAt, joinAheadTimeSeconds));
  useEffect(() => {
    if (!canJoinEarly) {
      const handle = setInterval(() => {
        setCanJoinEarly(checkCanJoinEarly(startsAt, joinAheadTimeSeconds));
      }, 1000);
      return () => clearInterval(handle);
    }
  }, [canJoinEarly, startsAt, joinAheadTimeSeconds]);
  return canJoinEarly;
};
const checkCanJoinEarly = (startsAt, joinAheadTimeSeconds) => {
  if (!startsAt) {
    return false;
  }
  return Date.now() >= +startsAt - (joinAheadTimeSeconds ?? 0) * 1000;
};
const useStyles = () => {
  const {
    theme
  } = useTheme();
  return useMemo(() => StyleSheet.create({
    container: {
      flex: 1,
      paddingBottom: theme.variants.insets.bottom,
      paddingLeft: theme.variants.insets.left,
      paddingRight: theme.variants.insets.right,
      paddingTop: theme.variants.insets.top,
      backgroundColor: theme.colors.sheetPrimary
    }
  }), [theme]);
};
//# sourceMappingURL=ViewerLivestream.js.map